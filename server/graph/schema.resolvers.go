package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"encoding/json"
	"fantasy-draft/graph/model"
)

// Divisions is the resolver for the divisions field.
func (r *conferenceResolver) Divisions(ctx context.Context, obj *model.Conference) ([]*model.Division, error) {
	rows, err := r.DB.Query(ctx, "SELECT id, name FROM divisions WHERE conference_id = $1 ORDER BY name", obj.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var divisions []*model.Division
	for rows.Next() {
		var d model.Division
		if err := rows.Scan(&d.ID, &d.Name); err != nil {
			return nil, err
		}
		divisions = append(divisions, &d)
	}
	return divisions, nil
}

// Conference is the resolver for the conference field.
func (r *divisionResolver) Conference(ctx context.Context, obj *model.Division) (*model.Conference, error) {
	var c model.Conference
	err := r.DB.QueryRow(ctx, `
		SELECT c.id, c.name 
		FROM conferences c 
		JOIN divisions d ON d.conference_id = c.id 
		WHERE d.id = $1
	`, obj.ID).Scan(&c.ID, &c.Name)
	if err != nil {
		return nil, err
	}
	return &c, nil
}

// Teams is the resolver for the teams field.
func (r *divisionResolver) Teams(ctx context.Context, obj *model.Division) ([]*model.Team, error) {
	rows, err := r.DB.Query(ctx, `
		SELECT id, city, state, name, abbreviation 
		FROM pro_teams 
		WHERE division_id = $1 
		ORDER BY city, name
	`, obj.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var teams []*model.Team
	for rows.Next() {
		var t model.Team
		if err := rows.Scan(&t.ID, &t.City, &t.State, &t.Name, &t.Abbreviation); err != nil {
			return nil, err
		}
		teams = append(teams, &t)
	}
	return teams, nil
}

// FullName resolves the fullName field on Player
func (r *playerResolver) FullName(ctx context.Context, obj *model.Player) (string, error) {
	return obj.FirstName + " " + obj.LastName, nil
}

// Team resolves the team field on Player
func (r *playerResolver) Team(ctx context.Context, obj *model.Player) (*model.Team, error) {
	var t model.Team
	err := r.DB.QueryRow(ctx, `
		SELECT id, city, state, name, abbreviation 
		FROM pro_teams 
		WHERE id = $1
	`, obj.TeamID).Scan(&t.ID, &t.City, &t.State, &t.Name, &t.Abbreviation)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

// YearlyStats resolves the yearlyStats field on Player
func (r *playerResolver) YearlyStats(ctx context.Context, obj *model.Player) ([]*model.YearlyStat, error) {
	rows, err := r.DB.Query(ctx, `
		SELECT id, year, sport_type, stats, fantasy_points, games_played, fantasy_points_per_game
		FROM yearly_stats 
		WHERE player_id = $1 
		ORDER BY year DESC
	`, obj.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var stats []*model.YearlyStat
	for rows.Next() {
		var s model.YearlyStat
		var statsJSON []byte
		var gamesPlayed *int
		var fpPerGame *float64

		if err := rows.Scan(&s.ID, &s.Year, &s.SportType, &statsJSON, &s.FantasyPoints, &gamesPlayed, &fpPerGame); err != nil {
			return nil, err
		}

		s.GamesPlayed = gamesPlayed
		s.FantasyPointsPerGame = fpPerGame

		// Parse the JSON stats
		if statsJSON != nil {
			var footballStats model.FootballStats
			if err := json.Unmarshal(statsJSON, &footballStats); err == nil {
				s.Stats = &footballStats
			}
		}

		stats = append(stats, &s)
	}
	return stats, nil
}

// Conferences is the resolver for the conferences field.
func (r *queryResolver) Conferences(ctx context.Context) ([]*model.Conference, error) {
	rows, err := r.DB.Query(ctx, "SELECT id, name FROM conferences ORDER BY name")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var conferences []*model.Conference
	for rows.Next() {
		var c model.Conference
		if err := rows.Scan(&c.ID, &c.Name); err != nil {
			return nil, err
		}
		conferences = append(conferences, &c)
	}
	return conferences, nil
}

// Conference is the resolver for the conference field.
func (r *queryResolver) Conference(ctx context.Context, id string) (*model.Conference, error) {
	var c model.Conference
	err := r.DB.QueryRow(ctx, "SELECT id, name FROM conferences WHERE id = $1", id).Scan(&c.ID, &c.Name)
	if err != nil {
		return nil, err
	}
	return &c, nil
}

// Divisions is the resolver for the divisions field.
func (r *queryResolver) Divisions(ctx context.Context) ([]*model.Division, error) {
	rows, err := r.DB.Query(ctx, "SELECT id, name, conference_id FROM divisions ORDER BY name")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var divisions []*model.Division
	for rows.Next() {
		var d model.Division
		var confID string
		if err := rows.Scan(&d.ID, &d.Name, &confID); err != nil {
			return nil, err
		}
		divisions = append(divisions, &d)
	}
	return divisions, nil
}

// Division is the resolver for the division field.
func (r *queryResolver) Division(ctx context.Context, id string) (*model.Division, error) {
	var d model.Division
	var confID string
	err := r.DB.QueryRow(ctx, "SELECT id, name, conference_id FROM divisions WHERE id = $1", id).Scan(&d.ID, &d.Name, &confID)
	if err != nil {
		return nil, err
	}
	return &d, nil
}

// Teams is the resolver for the teams field.
func (r *queryResolver) Teams(ctx context.Context) ([]*model.Team, error) {
	rows, err := r.DB.Query(ctx, `
		SELECT id, city, state, name, abbreviation, division_id 
		FROM pro_teams 
		ORDER BY city, name
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var teams []*model.Team
	for rows.Next() {
		var t model.Team
		var divID string
		if err := rows.Scan(&t.ID, &t.City, &t.State, &t.Name, &t.Abbreviation, &divID); err != nil {
			return nil, err
		}
		teams = append(teams, &t)
	}
	return teams, nil
}

// Team is the resolver for the team field.
func (r *queryResolver) Team(ctx context.Context, id string) (*model.Team, error) {
	var t model.Team
	var divID string
	err := r.DB.QueryRow(ctx, `
		SELECT id, city, state, name, abbreviation, division_id 
		FROM pro_teams 
		WHERE id = $1
	`, id).Scan(&t.ID, &t.City, &t.State, &t.Name, &t.Abbreviation, &divID)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

// Players is the resolver for the players field.
func (r *queryResolver) Players(ctx context.Context, position *model.Position, teamID *string, limit *int, offset *int) ([]*model.Player, error) {
	// Build dynamic query based on filters
	query := `
		SELECT id, first_name, last_name, position, team_id, height, weight, age, 
		       years_of_experience, draft_year, jersey_number, status, skill 
		FROM players 
		WHERE 1=1
	`
	args := []any{}
	argNum := 1

	if position != nil {
		query += " AND position = $" + string(rune('0'+argNum))
		args = append(args, position.String())
		argNum++
	}

	if teamID != nil {
		query += " AND team_id = $" + string(rune('0'+argNum))
		args = append(args, *teamID)
		argNum++
	}

	query += " ORDER BY last_name, first_name"

	if limit != nil {
		query += " LIMIT $" + string(rune('0'+argNum))
		args = append(args, *limit)
		argNum++
	}

	if offset != nil {
		query += " OFFSET $" + string(rune('0'+argNum))
		args = append(args, *offset)
	}

	rows, err := r.DB.Query(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	return scanPlayers(rows)
}

// Player is the resolver for the player field.
func (r *queryResolver) Player(ctx context.Context, id string) (*model.Player, error) {
	rows, err := r.DB.Query(ctx, `
		SELECT id, first_name, last_name, position, team_id, height, weight, age, 
		       years_of_experience, draft_year, jersey_number, status, skill 
		FROM players 
		WHERE id = $1
	`, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	players, err := scanPlayers(rows)
	if err != nil {
		return nil, err
	}
	if len(players) == 0 {
		return nil, nil
	}
	return players[0], nil
}

// SearchPlayers is the resolver for the searchPlayers field.
func (r *queryResolver) SearchPlayers(ctx context.Context, query string, limit *int) ([]*model.Player, error) {
	queryLimit := 20
	if limit != nil {
		queryLimit = *limit
	}

	rows, err := r.DB.Query(ctx, `
		SELECT id, first_name, last_name, position, team_id, height, weight, age, 
		       years_of_experience, draft_year, jersey_number, status, skill 
		FROM players 
		WHERE first_name ILIKE $1 OR last_name ILIKE $1 OR (first_name || ' ' || last_name) ILIKE $1
		ORDER BY last_name, first_name
		LIMIT $2
	`, "%"+query+"%", queryLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	return scanPlayers(rows)
}

// Division is the resolver for the division field.
func (r *teamResolver) Division(ctx context.Context, obj *model.Team) (*model.Division, error) {
	var d model.Division
	err := r.DB.QueryRow(ctx, `
		SELECT d.id, d.name 
		FROM divisions d 
		JOIN pro_teams t ON t.division_id = d.id 
		WHERE t.id = $1
	`, obj.ID).Scan(&d.ID, &d.Name)
	if err != nil {
		return nil, err
	}
	return &d, nil
}

// Players is the resolver for the players field.
func (r *teamResolver) Players(ctx context.Context, obj *model.Team) ([]*model.Player, error) {
	rows, err := r.DB.Query(ctx, `
		SELECT id, first_name, last_name, position, team_id, height, weight, age, 
		       years_of_experience, draft_year, jersey_number, status, skill 
		FROM players 
		WHERE team_id = $1 
		ORDER BY position, last_name, first_name
	`, obj.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	return scanPlayers(rows)
}

// Conference returns ConferenceResolver implementation.
func (r *Resolver) Conference() ConferenceResolver { return &conferenceResolver{r} }

// Division returns DivisionResolver implementation.
func (r *Resolver) Division() DivisionResolver { return &divisionResolver{r} }

// Player returns PlayerResolver implementation.
func (r *Resolver) Player() PlayerResolver { return &playerResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Team returns TeamResolver implementation.
func (r *Resolver) Team() TeamResolver { return &teamResolver{r} }

type conferenceResolver struct{ *Resolver }
type divisionResolver struct{ *Resolver }
type playerResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type teamResolver struct{ *Resolver }
